# javascript-interview-questions
## Preparing to interview

### 1) Что такое замыкание?

   Определение из MDN: "Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания."

   Для того, чтобы понять на примере, сравним две функции:
  ```
const func1 = function () {
     let count = 0;
     function inner() {
      ++count;
     }
     inner();
     return count;
   }

и

const func2 = function() {
  let count = 0
  return function() {
    return ++count
   }
}
```
Обе функции увеличивают переменную `count`, однако результат их вызовов будет разным 
`func1()` всегда будет возвращать 1
`func2()` возвращает нам другую функцию, поэтому
```
const closureFunc = func2()
closureFunc() // 1
closureFunc() // 2
```
Теперь мы видим, что `func2` сохраняет предыдущее значение переменной `count`, то есть замыкает его.

Зачем это нужно, если мы можем вынести `let count = 0` в глобальную область видимости и увеличивать ее с помощью более короткой функции? Дело в том, что использования глобальных переменных стоит избегать, так как их могут изменять другие сущности 

### 2) Чем различаются методы `call()`, `bind()` и `apply()`

Все перечисленные методы нужны для того, чтобы привязать к определенной функции некий контекст. Предположим, что у нас есть универсальная функция следующего вида:

```
function greetUser(){
   const greeting = "Привет, " + this.userName
}
```
Допустим, что у нас есть много объектов с пользователями, у каждого из которых есть поле userName. Чтобы не писать метод `greetUser()` для каждого объекта, мы можем просто вызвать данную функцию в контексте определенного объекта.

Пример с `call()`:

`greet.call(person1, arg1)`

 Особенность метода в том, что он вызовется сразу в месте написания кода

 Пример с `bind()`:

`greet.bind(person1, arg1)()`

Отличие от `call()` в том, что надо дописать круглые скобки, чтобы вызвать функцию

Пример с `apply()`:

`greet.apply(person1, [arg1, arg2])`

Отличается от остальных только тем, что аргументы нужно передавать в массиве




